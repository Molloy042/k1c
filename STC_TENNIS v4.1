import os
from playwright.sync_api import sync_playwright
import time
from datetime import date, timedelta, datetime
import random
import json

# --- é…ç½®ä¿¡æ¯ ---
BOOKING_URL = "https://members.swtc.ca/booking.html"
USERNAME_XPATH = '//*[@id="login-form-username"]'
PASSWORD_XPATH = '//*[@id="login-form-password"]'
CAPTCHA_XPATH = '//*[@id="rc-anchor-container"]/div[3]'
LOGIN_BUTTON_XPATH = '//*[@id="login-form-submit"]'
USER = 'Ssherryyan'
PASSWORD = 'Ysq.970317'
SUCCESS_URL_MARK = "profile.html?action=only_member_can_book"
login_page_url = "https://members.swtc.ca/login.html"

USER_DATA_DIR = "./user_data_chrome_final" 

# =======================================================
TEST_MODE = False
TEST_MODE_date_str = '2025-12-27'
delay_toggle = False
# =======================================================

TARGET_HOUR = 8
TARGET_MINUTE = 15
TEST_DELAY_SECONDS = 15 
MAX_BOOKED_COUNT = 6
DECISION_TIMEOUT_MS = 1000 

COURT_LIST = [10, 9, 8, 7, 6, 1, 2, 3, 4]
PREFERRED_GROUPS = [(13,14),(14,15),(15,16),(16, 17), (17, 18),(19, 20),(20,21), (21,22)]

# --- è®¡æ—¶å™¨ç±» (è¿˜åŸ) ---
class Timer:
    def __init__(self, step_name):
        self.step_name = step_name
        self.start_time = None
    def start(self):
        self.start_time = time.perf_counter()
    def stop(self):
        return time.perf_counter() - self.start_time

stopwatch = {}

def get_random_delay(min_ms=50, max_ms=150):
    return random.randint(min_ms, max_ms) / 1000.0

def delay_on_test_mode():
    global delay_toggle
    if delay_toggle:
        delay = 3
        time.sleep(delay)

def human_type(page, selector_or_xpath, text, step_name, delay_ms_min=80, delay_ms_max=200):
    timer = Timer(step_name)
    timer.start()
    locator = page.locator(selector_or_xpath)
    print(f"  -> æ­¥éª¤: {step_name} (èšç„¦è¾“å…¥æ¡†)")
    locator.click(delay=get_random_delay(100, 200))
    time.sleep(get_random_delay(500, 1500)) 
    print(f"  -> æ­¥éª¤: {step_name} (æ¨¡æ‹Ÿæ‰“å­—)")
    delay = random.randint(delay_ms_min, delay_ms_max)
    locator.type(text, delay=delay) 
    #time.sleep(get_random_delay(500, 1500)) 
    stopwatch[step_name.replace(' ', '_')] = timer.stop()
    return True

def random_scroll(page):
    """æ¨¡æ‹Ÿå°å¹…åº¦çš„éšæœºæ»šåŠ¨ï¼Œå¹¶æ‰“å°è¾“å‡ºã€‚"""
    if random.random() < 0.7: 
        scroll_amount = random.randint(50, 200)
        direction = random.choice([-1, 1]) 
        
        print(f"  -> æ­¥éª¤: æ¨¡æ‹Ÿéšæœºæ»šåŠ¨ ({'å‘ä¸Š' if direction == -1 else 'å‘ä¸‹'} {scroll_amount} åƒç´ )")
        page.mouse.wheel(0, direction * scroll_amount)
        time.sleep(get_random_delay(300, 600)) 

def ensure_correct_date_view(page, target_date_booking, date_str, is_next_month_needed):
    """ç¡®ä¿åœ¨é¢„å®šé¡µé¢ä¸”æ—¥æœŸæ­£ç¡®"""
    timer = Timer("Ensure_Date_View")
    timer.start()
    
    print(f"--- æ­¥éª¤: æ£€æŸ¥å’Œè®¾ç½®ç›®æ ‡æ—¥æœŸ {date_str} ---")
    
    try:
        page.goto(BOOKING_URL, timeout=5000)
    except Exception:
        stopwatch['Ensure_Date_View_Failed'] = timer.stop()
        print("  âŒ å¯¼èˆªå¤±è´¥æˆ–è¶…æ—¶")
        return False

    if "action=need_to_login_first" in page.url:
        stopwatch['Ensure_Date_View_Failed'] = timer.stop()
        print("  âš ï¸ ä»åœ¨ç™»å½•é¡µï¼Œç™»å½•çŠ¶æ€æ— æ•ˆ")
        return False 

    if is_next_month_needed:
        next_month_xpath = '//*[@id="calendar"]/div[1]/div[3]/i'
        try:
            print("  -> æ‰§è¡Œè·¨æœˆç‚¹å‡»")
            page.locator(next_month_xpath).wait_for(state='visible', timeout=200)
            page.locator(next_month_xpath).click(delay=get_random_delay()) 
        except:
            print("  -> è·¨æœˆæŒ‰é’®ä¸å¯è§æˆ–ç‚¹å‡»å¤±è´¥")
            pass
        time.sleep(get_random_delay(100, 300)) 

    date_button_xpath = f'//button[@data-value="{date_str}"]'
    try:
        print(f"  -> ç‚¹å‡»ç›®æ ‡æ—¥æœŸ {date_str} æŒ‰é’®")
        page.locator(date_button_xpath).click()
        #time.sleep(get_random_delay(50, 150)) 
        stopwatch['Ensure_Date_View'] = timer.stop()
        print(f"  âœ… ç›®æ ‡æ—¥æœŸè®¾ç½®æˆåŠŸã€‚ç”¨æ—¶: {stopwatch['Ensure_Date_View']:.3f}s")
        return True
    except:
        stopwatch['Ensure_Date_View_Failed'] = timer.stop()
        print("  âŒ ç›®æ ‡æ—¥æœŸæŒ‰é’®ä¸å¯è§æˆ–ç‚¹å‡»å¤±è´¥")
        return False

def run_booking_script():
    # === 1. æ—¶é—´è®¡ç®—é€»è¾‘ (è¿˜åŸå‰ç½®) ===
    today = date.today()
    days_after =  6
    target_date_booking = today + timedelta(days=days_after) 
    current_datetime = datetime.now()
    
    if TEST_MODE:
        target_time = current_datetime + timedelta(seconds=TEST_DELAY_SECONDS)
        date_str = TEST_MODE_date_str
    else:
        target_time = current_datetime.replace(hour=TARGET_HOUR, minute=TARGET_MINUTE, second=0, microsecond=200)
        if target_time < current_datetime - timedelta(seconds=600):
            target_time += timedelta(days=1)
            target_date_booking += timedelta(days=1)
        date_str = target_date_booking.strftime("%Y-%m-%d")

    wait_seconds = (target_time - datetime.now()).total_seconds()
    is_next_month_needed = (target_date_booking.year > today.year) or \
                           (target_date_booking.year == today.year and target_date_booking.month > today.month)

    print("\n=================================================")
    print(f"ğŸ¯ é¢„å®šç›®æ ‡ï¼š{date_str} {TARGET_HOUR:02}:{TARGET_MINUTE:02}:00")
    print("=================================================")
    timer_launch = Timer("Browser_Launch")
    timer_launch.start()
    with sync_playwright() as p:
        browser_args = [
            '--disable-blink-features=AutomationControlled', 
            '--no-sandbox',
            '--disable-infobars', 
        ]

        print(f"1. å¯åŠ¨æµè§ˆå™¨ (ç”¨æˆ·æ•°æ®ç›®å½•: {USER_DATA_DIR})...")
        
        context = p.chromium.launch_persistent_context(
            user_data_dir=USER_DATA_DIR, 
            headless=False,
            args=browser_args,
            viewport={"width": 1280, "height": 800}, 
            channel="chrome" 
        )
        
        page = context.pages[0]
        stopwatch['Browser_Launch'] = timer_launch.stop()
        print(f"   âœ… æµè§ˆå™¨å¯åŠ¨æˆåŠŸã€‚ç”¨æ—¶: {stopwatch['Browser_Launch']:.3f}s")

        # === 2. æ™ºèƒ½ç™»å½•æ£€æŸ¥ (è¡Œä¸ºæ¨¡æ‹Ÿé›†ä¸­åŒºåŸŸ) ===
        timer_login_check = Timer("Login_Check_and_Action")
        timer_login_check.start()
        
        print("\n2. æ£€æŸ¥ç™»å½•çŠ¶æ€...")
        page.goto("https://members.swtc.ca/login.html")
        time.sleep(1)
        
        if "action=already_logged_in" not in page.url or "action=only_member_can_book" in page.url:
            print("   âš ï¸ çŠ¶æ€å¤±æ•ˆï¼Œå¼€å§‹æ¨¡æ‹Ÿç™»å½•æ“ä½œ:")
            
            # 1. æ¨¡æ‹Ÿäººç±»è¾“å…¥ç”¨æˆ·å
            human_type(page, f"xpath={USERNAME_XPATH}", USER, "Input_Username", delay_ms_min=50, delay_ms_max=150)
            
            # 2. æ¨¡æ‹Ÿå°å¹…æ»šåŠ¨
            #random_scroll(page)
            
            # 3. æ¨¡æ‹Ÿäººç±»è¾“å…¥å¯†ç  (å…³é”®åŒºåŸŸ)
            human_type(page, f"xpath={PASSWORD_XPATH}", PASSWORD, "Input_Password", delay_ms_min=80, delay_ms_max=200)

            # 4. å†æ¬¡æ¨¡æ‹Ÿå°å¹…æ»šåŠ¨ (åœ¨ç­‰å¾…ç”¨æˆ·ä»‹å…¥å‰)
            #random_scroll(page)
            LOGIN_KEYWORD = "action=need_to_login_first"
            SUBMIT_BUTTON_XPATH = '//*[@id="login-form-submit"]'
            page.evaluate(f"""() => {{
                const btn = document.evaluate('{SUBMIT_BUTTON_XPATH}', document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
                if (btn) {{
                    btn.addEventListener('click', () => {{ window.__LOGIN_BUTTON_CLICKED = true; }});
                }}
            }}""")

            print("\n   ğŸ›‘ å‡†å¤‡å°±ç»ªï¼è¯·æ‰‹åŠ¨å®ŒæˆéªŒè¯ç å¹¶ç‚¹å‡»ç½‘é¡µä¸Šçš„ã€Loginã€‘æŒ‰é’®ã€‚")
            print("   ğŸ’¡ è„šæœ¬å°†åœ¨ä½ ç‚¹å‡»æŒ‰é’®çš„ç¬é—´è‡ªåŠ¨åˆ‡æ¢è‡³ç›‘æ§æ¨¡å¼...")
            
            try:
                # 3. â­ ç­‰å¾…ä¸¤ä¸ªé˜¶æ®µï¼šé¦–å…ˆæ˜¯æŒ‰é’®è¢«æŒ‰ä¸‹ï¼Œç„¶åæ˜¯ URL å‘ç”Ÿå˜åŒ–
                # ç¬¬ä¸€æ­¥ï¼šç­‰å¾…æŒ‰é’®æŒ‰ä¸‹æ ‡å¿—ä½
                page.wait_for_function("() => window.__LOGIN_BUTTON_CLICKED === true", timeout=60000)
                print("   ğŸ–±ï¸ æ£€æµ‹åˆ° Login æŒ‰é’®å·²æŒ‰ä¸‹ï¼Œæ­£åœ¨ç›‘æ§è·³è½¬...")

                # ç¬¬äºŒæ­¥ï¼šç­‰å¾… URL æ”¹å˜ï¼ˆä¸å†æ˜¯ç™»å½•é¡µï¼‰
                page.wait_for_function(
                    f"""() => window.location.href !== "{login_page_url}" && 
                               !window.location.href.includes("{LOGIN_KEYWORD}")""", 
                    timeout=30000
                )
                
                print(f"   âœ… ç™»å½•æˆåŠŸï¼å½“å‰ä½ç½®: {page.url}")
                
                # 4. å¼ºåˆ¶è¿”å›é¢„å®šé¡µå¹¶ç­‰å¾…å…³é”®åŠ è½½
                if "booking.html" not in page.url:
                    page.goto(BOOKING_URL, wait_until='domcontentloaded')
                
                print("   â³ æ­£åœ¨ç­‰å¾…åœºåœ°åŠ è½½æ¸²æŸ“ (è§£å†³ 13-15 ç‚¹æ¼åœºé—®é¢˜)...")
                # ç²¾å‡†ç­‰å¾…ï¼šç›´åˆ°é¡µé¢åˆ·å‡ºè‡³å°‘ä¸€ä¸ªå¸¦ data-value çš„æŒ‰é’®
                page.wait_for_selector('button[data-value]', timeout=5000)
                print("   âœ¨ åœºåœ°åŠ è½½å®Œæˆï¼Œå‡†å¤‡è¿›å…¥æŠ¢åœºå€’è®¡æ—¶ã€‚")
                
            except Exception as e:
                print(f"   âŒ è‡ªåŠ¨è¯†åˆ«å¤±è´¥: {e}")
                print("   ğŸ‘‰ è¯·æ‰‹åŠ¨æŒ‰å›è½¦å°è¯•å¼ºåˆ¶ç»§ç»­...")
                input()
            
        else:
            print("   âœ… ä¹‹å‰çš„ç™»å½•çŠ¶æ€æœ‰æ•ˆï¼Œæ— éœ€é‡æ–°ç™»å½•ï¼")

        if "booking.html" not in page.url:
            page.goto(BOOKING_URL, wait_until='domcontentloaded')
        stopwatch['Login_Check_and_Action'] = timer_login_check.stop()
        print(f"   ç”¨æ—¶ (åŒ…å«äººå·¥ä»‹å…¥): {stopwatch['Login_Check_and_Action']:.3f}s")
        go_to_profile_pag = True
        while (target_time - datetime.now()).total_seconds() > 120:
            if go_to_profile_pag:
                print("   â³ ç­‰å¾…è‡³æŠ¢åœºæ—¶é—´ï¼ŒæœŸé—´åˆ·æ–°ä¿æŒç™»å½•çŠ¶æ€...")
                page.goto("https://members.swtc.ca/profile.html", wait_until='domcontentloaded')
                go_to_profile_pag = False
            else:
                page.goto(BOOKING_URL, wait_until='domcontentloaded')
                go_to_profile_pag = True
            print(f"   âœ… åˆ·æ–°å®Œæˆï¼Œç­‰å¾…1åˆ†é’Ÿåå†æ¬¡åˆ·æ–°... å‰©ä½™æ—¶é—´: {(target_time - datetime.now()).total_seconds()}")
            time.sleep(60)

        if "booking.html" not in page.url:
            page.goto(BOOKING_URL)

        # === ğŸ¯ 3. é«˜ç²¾åº¦ç­‰å¾…é€»è¾‘ (è¿˜åŸä¸å‡çº§) ===
        timer_spin_lock = Timer("Spin_Lock_Wait")
        print("\n4. è¿›å…¥é«˜ç²¾åº¦ç­‰å¾…...")
        while (target_time - datetime.now()).total_seconds() > 5:
            print(f"   â³ ç­‰å¾…è‡³ç›®æ ‡æ—¶é—´ {(target_time - datetime.now()).total_seconds()} ...")
            time.sleep(5)
            
        timer_spin_lock.start()
        start = time.perf_counter()
        print("\n4. è¿›å…¥é«˜ç²¾åº¦ç­‰å¾…Spin_Lock_Wait...")
        wait_seconds = (target_time - datetime.now()).total_seconds()
        while (time.perf_counter() - start) < wait_seconds: pass
        stopwatch['Spin_Lock_Wait'] = timer_spin_lock.stop()
        time.sleep(0.001)
        print(f"   âœ… ç­‰å¾…ç»“æŸã€‚target_time:{target_time}, å½“å‰æ—¶é—´: {datetime.now()}")
        # === 4. æŠ¢åœºå¾ªç¯ (æ•´åˆä¼˜åŒ–ç‰ˆ) ===
        # æ­¤æ—¶æ—¶é—´åˆšåˆ° 8:15:00.000ï¼Œç«‹å³ç‚¹å‡»æ—¥æœŸ
        ensure_correct_date_view(page, target_date_booking, date_str, is_next_month_needed)

        # é¢„åŠ è½½ JS é€»è¾‘ï¼Œé¿å…åœ¨å¾ªç¯ä¸­é‡å¤å®šä¹‰å­—ç¬¦ä¸²
        JS_PICKER_SCRIPT = """
        (args) => {
            const { courtList, h1, h2, maxCount, currentBooked } = args;
            const findAndClick = (hStart, hEnd, preferredCid) => {
                const selector = `button[data-value="${hStart}00|${hEnd}00|${preferredCid}"].available`;
                const el = document.querySelector(selector);
                if (el) {
                    el.click(); // ç›´æ¥åœ¨æµè§ˆå™¨ç«¯è§¦å‘ç‚¹å‡»
                    return true;
                }
                return false;
            };

            let result = { batch: 0, cid: null };
            // å°è¯•é€‰ç¬¬ä¸€ä¸ªæ—¶æ®µ (Slot A)
            for (let cid of courtList) {
                if (findAndClick(h1.s, h1.e, cid)) {
                    result.batch = 1;
                    result.cid = cid;
                    // å¦‚æœé…é¢å…è®¸ï¼Œå°è¯•è¿é€‰ç¬¬äºŒä¸ªæ—¶æ®µ (Slot B)
                    if (currentBooked + 1 < maxCount) {
                        if (findAndClick(h2.s, h2.e, cid)) {
                            result.batch = 2;
                        }
                    }
                    break; 
                }
            }
            return result;
        }
        """

        booked_count = 0
        group_idx = 0
        while group_idx < len(PREFERRED_GROUPS):
            if booked_count >= MAX_BOOKED_COUNT: break
            timer_select = Timer(f"load_page_for_Group_{group_idx}")
            timer_select.start()
            h1_s, h1_e = PREFERRED_GROUPS[group_idx]
            h2_s, h2_e = h1_e, h1_e + 1
            
            # â­ å…³é”®ä¿®æ”¹ï¼šé«˜é¢‘ç›‘å¬ç‰¹å®šæ—¶æ®µçš„æŒ‰é’®æ¸²æŸ“
            # è¿™é‡Œçš„ selector ä¸“é—¨ç›¯ç€ä½ è¦çš„é‚£ä¸ªæ—¶é—´æ®µ
            sync_selector = f'button[data-value^="{h1_s}00|{h1_e}00|"]'
            
            try:
                # ä½¿ç”¨ state='attached' æ¯” 'visible' å¿«ï¼Œå› ä¸ºå…ƒç´ ä¸€è¿›å…¥ HTML æ ‘å°±è§¦å‘
                # timeout è®¾ä¸º 2000msï¼Œé˜²æ­¢é¡µé¢å½»åº•å¡æ­»
                page.wait_for_selector(sync_selector, state='attached', timeout=1000)
            except:
                print(f"âš ï¸ æ—¶æ®µ {h1_s}-{h1_e} æ¸²æŸ“è¶…æ—¶ï¼Œå¯èƒ½è¯¥æ—¶æ®µæ— çƒåœºæˆ–ç½‘ç»œæ‹¥å µã€‚")
                group_idx += 1
                continue
            stopwatch[f'load_page_for_Group_{group_idx}'] = timer_select.stop()

            # --- æ­¤æ—¶æŒ‰é’®å·²æ¸²æŸ“ï¼Œç«‹å³æ‰§è¡ŒåŸæœ¬çš„ JS æ³¨å…¥é€»è¾‘ ---
            timer_select = Timer(f"Select_and_Book_Group_{group_idx}")
            timer_select.start()
            
            picker_data = {
                "courtList": COURT_LIST,
                "h1": {"s": h1_s, "e": h1_e},
                "h2": {"s": h2_s, "e": h2_e},
                "maxCount": MAX_BOOKED_COUNT,
                "currentBooked": booked_count
            }

            try:
                # âš¡ æ‰§è¡Œ JSï¼šåœ¨æµè§ˆå™¨ä¾§å®Œæˆæœç´¢å’Œç‚¹å‡»ï¼Œè¿”å›ç»“æœ
                decision = page.evaluate(JS_PICKER_SCRIPT, picker_data)

                if decision["batch"] > 0:
                    print(f"  âœ… JS é€‰å®š {decision['batch']} åœº (åœºåœ° {decision['cid']})")
                    
                    # 1. æäº¤é¢„å®š
                    page.locator('//*[@id="book-button"]/div/a').click(delay=get_random_delay(10, 30))
                    
                    # 2. ç¡®è®¤é¢„å®š (é’ˆå¯¹é€Ÿåº¦ä¼˜åŒ–ï¼šä½¿ç”¨ attached çŠ¶æ€)
                    confirm_xpath = '//*[@id="cd-popup"]/div/ul/li[2]/a' if TEST_MODE else '//*[@id="cd-popup"]/div/ul/li[1]/a'
                    page.wait_for_selector(confirm_xpath, state='attached', timeout=2000)
                    page.locator(confirm_xpath).click()
                    
                    
                    
                    print(f"ğŸ† æˆåŠŸé¢„å®š {decision['batch']} åœº!")
                    booked_count += decision["batch"]
                    
                    # å¦‚æœè¿˜éœ€è¦ç»§ç»­è®¢ï¼Œåˆ·æ–°/å›åˆ°æ—¥æœŸè§†å›¾
                    if booked_count < MAX_BOOKED_COUNT:
                        ensure_correct_date_view(page, target_date_booking, date_str, is_next_month_needed)
                else:
                    print(f"  âŒ æ—¶æ®µ {h1_s}-{h1_e} æ— å¯ç”¨åœºåœ°ï¼Œè·³è¿‡ã€‚")

            except Exception as e:
                print(f"âŒ è¿è¡Œå¼‚å¸¸: {e}")
                ensure_correct_date_view(page, target_date_booking, date_str, is_next_month_needed)

            stopwatch[f'Select_Group_{h1_s}_{h1_e}'] = timer_select.stop()
            #time.sleep(5)
            
            # ç´¢å¼•è·³è½¬é€»è¾‘
            group_idx += 1
            # å¦‚æœ Slot B ä¹Ÿæ˜¯æˆ‘ä»¬é€‰ä¸­çš„ï¼Œé€»è¾‘ä¸Šå¯ä»¥å¤šè·³ä¸€ä¸ª Index (å–å†³äº PREFERRED_GROUPS çš„æ’å¸ƒ)

        
        print("\n=================================")
        print(f"æ€»è®¡é¢„å®šåœºåœ°æ•°: {booked_count}")
        print("=== âœ¨ è¯¦ç»†è€—æ—¶ç»Ÿè®¡ (ç§’) ===")
        print("| æ­¥éª¤æè¿°                      | è€—æ—¶ (s) |")
        print("|:------------------------------|:---------|")
        for step, t in stopwatch.items():
            print(f"| {step.ljust(30)}| {t:.3f}   |")
        print("=================================")
        
        print("âœ… è„šæœ¬æ‰§è¡Œå®Œæ¯•ï¼Œæµè§ˆå™¨çŠ¶æ€å·²ä¿å­˜ã€‚")
        input("æŒ‰å›è½¦å…³é—­...")
        context.close()

if __name__ == '__main__':
    run_booking_script()
