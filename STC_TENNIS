import os
from playwright.sync_api import sync_playwright
import time
from datetime import date, timedelta, datetime
import random
import json

# --- é…ç½®ä¿¡æ¯ ---
BOOKING_URL = "https://members.swtc.ca/booking.html"
USERNAME_XPATH = '//*[@id="login-form-username"]'
PASSWORD_XPATH = '//*[@id="login-form-password"]'
CAPTCHA_XPATH = '//*[@id="rc-anchor-container"]/div[3]'
LOGIN_BUTTON_XPATH = '//*[@id="login-form-submit"]'
USER = 'Ssherryyan'
PASSWORD = 'Ysq.970317'

# ğŸ“ æµè§ˆå™¨æ•°æ®ä¿å­˜ç›®å½• (ä¿å­˜ç™»å½•çŠ¶æ€å’Œä¿¡ä»»æŒ‡çº¹)
USER_DATA_DIR = "./user_data_chrome_final" 

# =======================================================
TEST_MODE = True
# =======================================================

TARGET_HOUR = 8
TARGET_MINUTE = 15
TEST_DELAY_SECONDS = 15 
MAX_BOOKED_COUNT = 6

DEFAULT_COURT_PRIORITIES = [[10, 9, 8, 7, 6], [1, 2, 3, 4]]
PREFERRED_GROUPS = [(13, 14), (14, 15), (15, 16), (16, 17), (17, 18),(12, 13), (22, 23), (8, 9)]

# --- è®¡æ—¶å™¨ç±» (ä¿æŒä¸å˜) ---
class Timer:
    def __init__(self, step_name):
        self.step_name = step_name
        self.start_time = None
    def start(self):
        self.start_time = time.perf_counter()
    def stop(self):
        elapsed = time.perf_counter() - self.start_time
        return elapsed

stopwatch = {}

def get_random_delay(min_ms=50, max_ms=150):
    """ç”Ÿæˆä¸€ä¸ªæ¨¡æ‹Ÿäººç±»ååº”æ—¶é—´çš„éšæœºå»¶è¿Ÿ (æ¯«ç§’)"""
    return random.randint(min_ms, max_ms) / 1000.0

# â­ å‡çº§çš„æ¨¡æ‹Ÿäººç±»æ‰“å­—
def human_type(page, selector_or_xpath, text, step_name, delay_ms_min=80, delay_ms_max=200):
    """ä½¿ç”¨éšæœºå»¶è¿Ÿæ¨¡æ‹ŸçœŸäººæŒ‰é”®è¾“å…¥ï¼Œå¹¶è®°å½•æ—¶é—´ã€‚"""
    timer = Timer(step_name)
    timer.start()
    
    locator = page.locator(selector_or_xpath)
    
    print(f"  -> æ­¥éª¤: {step_name} (èšç„¦è¾“å…¥æ¡†)")
    locator.click(delay=get_random_delay(100, 300))
    time.sleep(get_random_delay(500, 2000)) 
    
    print(f"  -> æ­¥éª¤: {step_name} (æ¨¡æ‹Ÿæ‰“å­—)")
    delay = random.randint(delay_ms_min, delay_ms_max)
    locator.type(text, delay=delay) 
    time.sleep(get_random_delay(500, 2000)) 
    
    stopwatch[step_name.replace(' ', '_')] = timer.stop()
    print(f"  -> ç”¨æ—¶: {stopwatch[step_name.replace(' ', '_')]:.3f}s")
    return True
    


def random_scroll(page):
    """æ¨¡æ‹Ÿå°å¹…åº¦çš„éšæœºæ»šåŠ¨ï¼Œå¹¶æ‰“å°è¾“å‡ºã€‚"""
    if random.random() < 0.7: 
        scroll_amount = random.randint(50, 200)
        direction = random.choice([-1, 1]) 
        
        print(f"  -> æ­¥éª¤: æ¨¡æ‹Ÿéšæœºæ»šåŠ¨ ({'å‘ä¸Š' if direction == -1 else 'å‘ä¸‹'} {scroll_amount} åƒç´ )")
        page.mouse.wheel(0, direction * scroll_amount)
        time.sleep(get_random_delay(300, 600)) 

def ensure_correct_date_view(page, target_date_booking, date_str, is_next_month_needed):
    """ç¡®ä¿åœ¨é¢„å®šé¡µé¢ä¸”æ—¥æœŸæ­£ç¡®"""
    timer = Timer("Ensure_Date_View")
    timer.start()
    
    print(f"--- æ­¥éª¤: æ£€æŸ¥å’Œè®¾ç½®ç›®æ ‡æ—¥æœŸ {date_str} ---")
    
    try:
        page.goto(BOOKING_URL, timeout=5000)
        #time.sleep(get_random_delay(200, 500)) 
    except Exception:
        stopwatch['Ensure_Date_View_Failed'] = timer.stop()
        print("  âŒ å¯¼èˆªå¤±è´¥æˆ–è¶…æ—¶")
        return False

    if "action=need_to_login_first" in page.url:
        stopwatch['Ensure_Date_View_Failed'] = timer.stop()
        print("  âš ï¸ ä»åœ¨ç™»å½•é¡µï¼Œç™»å½•çŠ¶æ€æ— æ•ˆ")
        return False 

    if is_next_month_needed:
        next_month_xpath = '//*[@id="calendar"]/div[1]/div[3]/i'
        try:
            print("  -> æ‰§è¡Œè·¨æœˆç‚¹å‡»")
            page.locator(next_month_xpath).wait_for(state='visible', timeout=200)
            page.locator(next_month_xpath).click(delay=get_random_delay()) 
        except:
            print("  -> è·¨æœˆæŒ‰é’®ä¸å¯è§æˆ–ç‚¹å‡»å¤±è´¥")
            pass
        time.sleep(get_random_delay(100, 300)) 

    date_button_xpath = f'//button[@data-value="{date_str}"]'
    try:
        print(f"  -> ç‚¹å‡»ç›®æ ‡æ—¥æœŸ {date_str} æŒ‰é’®")
        page.locator(date_button_xpath).click()
        #time.sleep(get_random_delay(50, 150)) 
        stopwatch['Ensure_Date_View'] = timer.stop()
        print(f"  âœ… ç›®æ ‡æ—¥æœŸè®¾ç½®æˆåŠŸã€‚ç”¨æ—¶: {stopwatch['Ensure_Date_View']:.3f}s")
        return True
    except:
        stopwatch['Ensure_Date_View_Failed'] = timer.stop()
        print("  âŒ ç›®æ ‡æ—¥æœŸæŒ‰é’®ä¸å¯è§æˆ–ç‚¹å‡»å¤±è´¥")
        return False

def run_booking_script():
    # === 1. è®¡ç®—é€»è¾‘ (ä¿æŒå‰ç½®) ===
    today = date.today()
    days_after = 3 if TEST_MODE else 6
    target_date_booking = today + timedelta(days=days_after) 
    current_datetime = datetime.now()
    
    if TEST_MODE:
        target_time = current_datetime + timedelta(seconds=TEST_DELAY_SECONDS)
    else:
        target_time = current_datetime.replace(hour=TARGET_HOUR, minute=TARGET_MINUTE, second=0, microsecond=0)
        if target_time < current_datetime - timedelta(seconds=600):
            target_time += timedelta(days=1)
            target_date_booking += timedelta(days=1)

    date_str = target_date_booking.strftime("%Y-%m-%d")
    wait_seconds = (target_time - current_datetime).total_seconds()
    is_next_month_needed = (target_date_booking.year > today.year) or \
                           (target_date_booking.year == today.year and target_date_booking.month > today.month)
    if TEST_MODE:
        date_str = '2025-12-16'
    print("\n=================================================")
    print(f"ğŸ¯ é¢„å®šä»»åŠ¡ç›®æ ‡ï¼š{date_str} {TARGET_HOUR:02}:{TARGET_MINUTE:02}:00")
    print(f"â³ è·ç¦»ç›®æ ‡æ—¶é—´ç­‰å¾…ï¼š{wait_seconds:.1f} ç§’")
    print("=================================================")

    # =======================================================
    # ğŸ•µï¸ å¯åŠ¨æŒä¹…åŒ–å’Œæœ€é«˜çº§éšè”½æµè§ˆå™¨
    # =======================================================
    timer_launch = Timer("Browser_Launch")
    timer_launch.start()
    
    with sync_playwright() as p:
        
        browser_args = [
            '--disable-blink-features=AutomationControlled', 
            '--no-sandbox',
            '--disable-infobars', 
        ]

        print(f"1. å¯åŠ¨æµè§ˆå™¨ (ç”¨æˆ·æ•°æ®ç›®å½•: {USER_DATA_DIR})...")
        
        context = p.chromium.launch_persistent_context(
            user_data_dir=USER_DATA_DIR, 
            headless=False,
            args=browser_args,
            viewport={"width": 1280, "height": 800}, 
            channel="chrome" 
        )
        
        page = context.pages[0]
        stopwatch['Browser_Launch'] = timer_launch.stop()
        print(f"   âœ… æµè§ˆå™¨å¯åŠ¨æˆåŠŸã€‚ç”¨æ—¶: {stopwatch['Browser_Launch']:.3f}s")

        # === 2. æ™ºèƒ½ç™»å½•æ£€æŸ¥ (è¡Œä¸ºæ¨¡æ‹Ÿé›†ä¸­åŒºåŸŸ) ===
        timer_login_check = Timer("Login_Check_and_Action")
        timer_login_check.start()
        
        print("\n2. æ£€æŸ¥ç™»å½•çŠ¶æ€...")
        page.goto(BOOKING_URL, wait_until='domcontentloaded')
        time.sleep(3)
        
        if "action=need_to_login_first" in page.url:
            print("   âš ï¸ çŠ¶æ€å¤±æ•ˆï¼Œå¼€å§‹æ¨¡æ‹Ÿç™»å½•æ“ä½œ:")
            
            # 1. æ¨¡æ‹Ÿäººç±»è¾“å…¥ç”¨æˆ·å
            human_type(page, f"xpath={USERNAME_XPATH}", USER, "Input_Username", delay_ms_min=50, delay_ms_max=150)
            
            # 2. æ¨¡æ‹Ÿå°å¹…æ»šåŠ¨
            #random_scroll(page)
            
            # 3. æ¨¡æ‹Ÿäººç±»è¾“å…¥å¯†ç  (å…³é”®åŒºåŸŸ)
            human_type(page, f"xpath={PASSWORD_XPATH}", PASSWORD, "Input_Password", delay_ms_min=80, delay_ms_max=200)

            # 4. å†æ¬¡æ¨¡æ‹Ÿå°å¹…æ»šåŠ¨ (åœ¨ç­‰å¾…ç”¨æˆ·ä»‹å…¥å‰)
            random_scroll(page)
            
            
            print("\n   ğŸ›‘ğŸ›‘ğŸ›‘ éœ€äººå·¥ä»‹å…¥ï¼è¯·åœ¨æµè§ˆå™¨ä¸­æ‰‹åŠ¨è§£å†³éªŒè¯ç /ç‚¹å‡»ç™»å½•ã€‚")
            print("   ğŸ‘‰ ç™»å½•æˆåŠŸå¹¶çœ‹åˆ°é¢„å®šé¡µé¢åï¼Œè¯·åœ¨ç»ˆç«¯æŒ‰ã€å›è½¦ã€‘ç»§ç»­...")
            input() 
            #time.sleep(10)
            
            if "booking.html" not in page.url:
                page.goto(BOOKING_URL)
        else:
            print("   âœ… ä¹‹å‰çš„ç™»å½•çŠ¶æ€æœ‰æ•ˆï¼Œæ— éœ€é‡æ–°ç™»å½•ï¼")

        stopwatch['Login_Check_and_Action'] = timer_login_check.stop()
        print(f"   ç”¨æ—¶ (åŒ…å«äººå·¥ä»‹å…¥): {stopwatch['Login_Check_and_Action']:.3f}s")


        # === 4. é«˜ç²¾åº¦ç­‰å¾… ===
        timer_spin_lock = Timer("Spin_Lock_Wait")
        print("\n4. è¿›å…¥é«˜ç²¾åº¦ç­‰å¾…...")
        if wait_seconds > 0:
            if wait_seconds > 5.0:
                time.sleep(wait_seconds - 0.1)
                wait_seconds = (target_time - datetime.now()).total_seconds()
            
            timer_spin_lock.start()
            start = time.perf_counter()
            while (time.perf_counter() - start) < wait_seconds: pass
            stopwatch['Spin_Lock_Wait'] = timer_spin_lock.stop()
            print(f"   âœ… ç­‰å¾…ç»“æŸã€‚Spin Lock è€—æ—¶: {stopwatch['Spin_Lock_Wait']:.3f}s")

        print("=================================================")
        print("ğŸ”” å¼€å§‹æŠ¢åœºæ“ä½œï¼")
        print("=================================================")

        # 3. ç¡®ä¿æ—¥æœŸè§†å›¾æ­£ç¡®
        print("\n3. ç¡®ä¿é¡µé¢è§†å›¾å’Œç›®æ ‡æ—¥æœŸ...")
        if not ensure_correct_date_view(page, target_date_booking, date_str, is_next_month_needed):
            print("âŒ è§†å›¾è®¾ç½®å¤±è´¥ï¼Œè„šæœ¬ç»ˆæ­¢ã€‚")
            context.close()
            return
            
        # === 5. æŠ¢åœºå¾ªç¯ ===
        booked_count = 0
        timer_loop = Timer("Total_Booking_Loop")
        timer_loop.start()

        for start_h, end_h in PREFERRED_GROUPS:
            if booked_count >= MAX_BOOKED_COUNT: break
            
            time_slot_label = f"{start_h}:00-{end_h}:00"
            start_time_str, end_time_str = f"{start_h}00", f"{end_h}00"
            
            slot_booked_in_time = False
            for group_index, court_list in enumerate(DEFAULT_COURT_PRIORITIES):
                if slot_booked_in_time: break
                
                print(f"  -> å°è¯•æ—¶é—´æ®µ {time_slot_label} (ä¼˜å…ˆçº§ {group_index+1})...")
                for court_id in court_list:
                    slot_xpath = f'//button[@data-value="{start_time_str}|{end_time_str}|{court_id}" and contains(@class, "available")]'
                    try:
                        timer_click = Timer(f"Court_{court_id}_Booking_Attempt")
                        timer_click.start()

                        loc = page.locator(slot_xpath)
                        loc.wait_for(state='visible', timeout=50) 
                        
                        # ğŸ¾ é¢„å®šæ—¶é—´æ®µç‚¹å‡»
                        loc.click(delay=get_random_delay(30, 80)) 
                        #time.sleep(get_random_delay(50, 100)) 

                        # ç¡®è®¤ 1: é¢„å®šæŒ‰é’®
                        btn1 = '//*[@id="book-button"]/div/a'
                        page.locator(btn1).wait_for(state='visible', timeout=100)
                        page.locator(btn1).click(delay=get_random_delay(50, 150))
                        #time.sleep(get_random_delay(50, 100)) 
                        
                        # ç¡®è®¤ 2: æœ€ç»ˆç¡®è®¤/å–æ¶ˆ
                        btn2 = '//*[@id="cd-popup"]/div/ul/li[2]/a' if TEST_MODE else '//*[@id="cd-popup"]/div/ul/li[1]/a'
                        page.locator(btn2).wait_for(state='visible', timeout=100)
                        page.locator(btn2).click(delay=get_random_delay(30, 80))
                        
                        stopwatch[f'Booking_Success_Court_{court_id}'] = timer_click.stop()
                        print(f"  ğŸ† é¢„å®šæˆåŠŸ: åœºåœ° {court_id}ã€‚ç”¨æ—¶: {stopwatch[f'Booking_Success_Court_{court_id}']:.3f}s")
                        booked_count += 1
                        slot_booked_in_time = True
                        
                        if booked_count < MAX_BOOKED_COUNT:
                            ensure_correct_date_view(page, target_date_booking, date_str, is_next_month_needed)
                        break
                    except Exception as e: 
                        print(f"  - åœºåœ° {court_id} ä¸å¯ç”¨æˆ–ç‚¹å‡»å¤±è´¥: {e.__class__.__name__}")
                        continue
        
        stopwatch['Total_Booking_Loop'] = timer_loop.stop()
        
        # === 6. ç»Ÿè®¡è¾“å‡º ===
        print("\n=================================")
        print(f"æ€»è®¡é¢„å®šåœºåœ°æ•°: {booked_count}")
        print("=== âœ¨ è¯¦ç»†è€—æ—¶ç»Ÿè®¡ (ç§’) ===")
        print("| æ­¥éª¤æè¿°                      | è€—æ—¶ (s) |")
        print("|:------------------------------|:---------|")
        for step, t in stopwatch.items():
            print(f"| {step.ljust(30)}| {t:.3f}   |")
        print("=================================")
        
        if TEST_MODE:
            input("TEST_MODE: æŒ‰å›è½¦å…³é—­æµè§ˆå™¨...")
        
        context.close()
        print("âœ… è„šæœ¬æ‰§è¡Œå®Œæ¯•ï¼Œæµè§ˆå™¨çŠ¶æ€å·²ä¿å­˜ã€‚")

if __name__ == '__main__':
    run_booking_script()
