import os
import time
import random
from datetime import date, timedelta, datetime
from playwright.sync_api import sync_playwright

# ================= é…ç½®ä¿¡æ¯ =================
USER = 'Ssherryyan'
PASSWORD = 'Ysq.970317'
BOOKING_URL = "https://members.swtc.ca/booking.html"
LOGIN_PAGE_URL = "https://members.swtc.ca/login.html"
USER_DATA_DIR = "./user_data_chrome_final" 

# --- å…ƒç´ å®šä½ (XPath) ---
USERNAME_XPATH = '//*[@id="login-form-username"]'
PASSWORD_XPATH = '//*[@id="login-form-password"]'
LOGIN_BUTTON_XPATH = '//*[@id="login-form-submit"]'
TEST_MODE = True
TEST_MODE_date_str = '2026-01-08'
# --- æŠ¢åœºè®¾ç½® ---
TARGET_HOUR = 8
TARGET_MINUTE = 15
MAX_BOOKED_COUNT = 6
COURT_LIST = [10, 9, 8, 7, 6, 1, 2, 3, 4]
PREFERRED_GROUPS = [(13,14),(14,15),(15,16),(16, 17), (17, 18),(19, 20),(20,21), (21,22)]

# ================= ç‰©ç†çº§æ¨¡æ‹Ÿå‡½æ•° =================
class Timer:
    def __init__(self, step_name):
        self.step_name = step_name
        self.start_time = None
    def start(self):
        self.start_time = time.perf_counter()
    def stop(self):
        return time.perf_counter() - self.start_time

stopwatch = {}
def ensure_correct_date_view(page, target_date_booking, date_str, is_next_month_needed):
    """ç¡®ä¿åœ¨é¢„å®šé¡µé¢ä¸”æ—¥æœŸæ­£ç¡®"""
    timer = Timer("Ensure_Date_View")
    timer.start()
    
    print(f"--- æ­¥éª¤: æ£€æŸ¥å’Œè®¾ç½®ç›®æ ‡æ—¥æœŸ {date_str} ---")
    if "booking.html" not in page.url:
        try:
            page.goto(BOOKING_URL, timeout=5000)
        except Exception:
            stopwatch['Ensure_Date_View_Failed'] = timer.stop()
            print("  âŒ å¯¼èˆªå¤±è´¥æˆ–è¶…æ—¶")
            return False

    if "action=need_to_login_first" in page.url:
        stopwatch['need_to_login_first_failed'] = timer.stop()
        print("  âš ï¸ ä»åœ¨ç™»å½•é¡µï¼Œç™»å½•çŠ¶æ€æ— æ•ˆ")
        return False 

    if page.locator('xpath=//*[@id="calendar"]').count() > 0:
        print("  âœ… å·²åœ¨é¢„å®šé¡µé¢ï¼Œæ—¥å†è§†å›¾åŠ è½½å®Œæˆ")
        if is_next_month_needed:
            next_month_xpath = '//*[@id="calendar"]/div[1]/div[3]/i'
            try:
                print("  -> æ‰§è¡Œè·¨æœˆç‚¹å‡»")
                #page.locator(next_month_xpath).wait_for(state='visible', timeout=200)
                page.locator(next_month_xpath).click() 
            except:
                print("  -> è·¨æœˆæŒ‰é’®ä¸å¯è§æˆ–ç‚¹å‡»å¤±è´¥")
                pass
            #time.sleep(get_random_delay(100, 300)) 
        
        date_button_xpath = f'//button[@data-value="{date_str}"]'
        try:
            print(f"  -> ç‚¹å‡»ç›®æ ‡æ—¥æœŸ {date_str} æŒ‰é’®")
            page.locator(date_button_xpath).click()
            #time.sleep(get_random_delay(50, 150)) 
            stopwatch['Ensure_Date_View'] = timer.stop()
            print(f"  âœ… ç›®æ ‡æ—¥æœŸè®¾ç½®æˆåŠŸã€‚ç”¨æ—¶: {stopwatch['Ensure_Date_View']:.3f}s")
            return True
        except:
            stopwatch['Ensure_Date_View_Failed'] = timer.stop()
            print("  âŒ ç›®æ ‡æ—¥æœŸæŒ‰é’®ä¸å¯è§æˆ–ç‚¹å‡»å¤±è´¥")
            return False

def get_random_delay(min_ms=50, max_ms=150):
    return random.randint(min_ms, max_ms) / 1000.0

def delay_on_test_mode():
    global delay_toggle
    if delay_toggle:
        delay = 3
        time.sleep(delay)
def physical_click_relative(page, base_xpath, offset_y=-100, label="ç›®æ ‡åŒºåŸŸ"):
    """
    åŸºäºä¸€ä¸ªåŸºå‡†å…ƒç´ ï¼Œè¿›è¡Œç›¸å¯¹ä½ç§»ç‚¹å‡»
    """
    print(f"  -> æ­£åœ¨æ ¹æ® {base_xpath} å®šä½ {label}...")
    try:
        element = page.locator(f"xpath={base_xpath}")
        element.wait_for(state="visible", timeout=5000)
        box = element.bounding_box()
        
        if box:
            # 1. è®¡ç®—åŸºå‡†å…ƒç´ ï¼ˆç™»å½•æŒ‰é’®ï¼‰ä¸­å¿ƒç‚¹
            base_center_x = box['x'] + box['width'] / 2
            base_center_y = box['y'] + box['height'] / 2

            # 2. è®¡ç®—åç§»åçš„ç›®æ ‡ç‚¹ (å‘ä¸Šç§»åŠ¨ 100 åƒç´ ï¼Œæ‰€ä»¥æ˜¯ -100)
            target_x = base_center_x + random.uniform(-5, 5) # æ¨ªå‘å¾®è°ƒ
            target_y = base_center_y + offset_y + random.uniform(-5, 5) # çºµå‘åç§»

            # 3. æ¨¡æ‹Ÿé¼ æ ‡å¹³æ»‘æ»‘å…¥ç›®æ ‡ç‚¹
            print(f"  -> é¼ æ ‡æ­£åœ¨ä»å½“å‰ä½ç½®ç§»å‘ç›®æ ‡ç‚¹: ({target_x}, {target_y})")
            page.mouse.move(target_x, target_y, steps=random.randint(20, 30))
            
            # 4. å®‰å®šåœé¡¿ (æ¨¡æ‹ŸçœŸäººç¡®è®¤ç‚¹å‡»ä½ç½®)
            time.sleep(random.uniform(0.6, 1.0))

            # 5. æ‰§è¡Œç‰©ç†ç‚¹å‡»åŠ¨ä½œ (æŒ‰ä¸‹ -> åœé¡¿ -> å¼¹èµ·)
            page.mouse.down()
            time.sleep(random.uniform(0.1, 0.2))
            page.mouse.up()
            
            print(f"  âœ… {label} ç‰©ç†ç‚¹å‡»å®Œæˆ (åç§»é‡: {offset_y}px)")
            return True
    except Exception as e:
        print(f"  âŒ å®šä½æˆ–ç‚¹å‡»å¤±è´¥: {e}")
    return False

def human_type(page, xpath, text, label):
    """æ¨¡æ‹ŸçœŸäººæ‰“å­—ï¼šå…ˆç‚¹å‡»èšç„¦ï¼Œå†é€å­—è¾“å…¥"""
    try:
        element = page.locator(f"xpath={xpath}")
        box = element.bounding_box()
        if box:
            page.mouse.click(box['x'] + box['width']/2, box['y'] + box['height']/2)
        time.sleep(0.5)
        element.type(text, delay=random.randint(80, 160))
        print(f"  âœ… {label} è¾“å…¥å®Œæˆ")
    except:
        print(f"  âŒ {label} è¾“å…¥å¤±è´¥")

# ================= ä¸»è¿è¡Œè„šæœ¬ =================

def run_booking_script():
    # 1. é¢„è®¡ç®—æ—¥æœŸ
    today = date.today()
    target_date_booking = today + timedelta(days=6)
    date_str = target_date_booking.strftime("%Y-%m-%d")
    is_next_month = target_date_booking.month > today.month
    current_datetime = datetime.now()

    # ç›®æ ‡æ—¶é—´ 08:15:00.200
    target_time = datetime.now().replace(hour=TARGET_HOUR, minute=TARGET_MINUTE, second=0, microsecond=200)
    if target_time < current_datetime - timedelta(seconds=600): 
        target_time += timedelta(days=1)
        date_str = target_time.strftime("%Y-%m-%d")

    if TEST_MODE:
        target_time = current_datetime + timedelta(seconds=15)
        date_str = TEST_MODE_date_str

    #wait until 08:05:00 to start,comapre with real time
    print("=================================")
    while (target_time - datetime.now()).total_seconds() > 300:#check real time every minute
        print(f"â³ è„šæœ¬å°†åœ¨ç›®æ ‡æ—¶é—´å‰5åˆ†é’Ÿå¯åŠ¨ï¼Œå½“å‰æ—¶é—´: {datetime.now().strftime('%H:%M:%S')}ï¼Œç›®æ ‡æ—¶é—´: {target_time.strftime('%H:%M:%S')}")
        time.sleep(60)
    

    print(f"\nğŸš€ è„šæœ¬å¯åŠ¨ã€‚ç›®æ ‡æ—¥æœŸ: {date_str}ï¼ŒæŠ¢åœºæ—¶é—´: {target_time}")

    with sync_playwright() as p:
        context = p.chromium.launch_persistent_context(
            user_data_dir=USER_DATA_DIR, 
            headless=False,
            args=['--disable-blink-features=AutomationControlled'],
            viewport={"width": 1280, "height": 800},
            channel="chrome"
        )
        page = context.pages[0]
        timer_login_check = Timer("Login_Check_and_Action")
        timer_login_check.start()
        # --- ç¬¬ä¸€æ­¥ï¼šç™»å½• ---
        print("\n[1] æ£€æŸ¥ç™»å½•çŠ¶æ€...")
        page.goto(LOGIN_PAGE_URL)
        time.sleep(2)

        if "already_logged_in" not in page.url:
            print("  âš ï¸ éœ€è¦ç™»å½•ï¼Œå¼€å§‹æ‰§è¡Œç‰©ç†çº§æ“ä½œ...")
            human_type(page, USERNAME_XPATH, USER, "ç”¨æˆ·å")
            time.sleep(0.5)
            human_type(page, PASSWORD_XPATH, PASSWORD, "å¯†ç ")
            time.sleep(1)

            # æ ¸å¿ƒæ“ä½œï¼šå®šä½ç™»å½•æŒ‰é’®ä¸­å¿ƒï¼Œå‘ä¸Šç§»åŠ¨50åƒç´ ç‚¹å‡»éªŒè¯ç 
            physical_click_relative(page, LOGIN_BUTTON_XPATH, offset_y=-55, label="reCAPTCHA æ¡†")
            
            # ç­‰å¾…éªŒè¯ç å¤„ç†æ—¶é—´
            time.sleep(3) 

            # ç‚¹å‡»ç™»å½•æŒ‰é’®
            # (offset_y=0 è¡¨ç¤ºç›´æ¥ç‚¹ä¸­å¿ƒ)
            physical_click_relative(page, LOGIN_BUTTON_XPATH, offset_y=0, label="ç™»å½•æŒ‰é’®")

            # ç›‘æ§è·³è½¬
            print("  â³ æ­£åœ¨ç›‘æ§é¡µé¢è·³è½¬...")
            try:
                page.wait_for_function(f"() => window.location.href !== '{LOGIN_PAGE_URL}'", timeout=8000)
                print("  ğŸ‰ ç™»å½•æˆåŠŸï¼")
            except:
                print("\n  ğŸ›‘ è‡ªåŠ¨ç™»å½•æœªè§¦å‘è·³è½¬ã€‚")
                print("  ğŸ‘‰ å¯èƒ½éœ€è¦ä½ æ‰‹åŠ¨è¿‡ä¸€ä¸‹é€‰å›¾æŒ‘æˆ˜ã€‚è¯·åœ¨æµè§ˆå™¨æ“ä½œï¼Œè„šæœ¬å°†è‡ªåŠ¨æ„Ÿåº”è·³è½¬...")
                page.wait_for_function(f"() => window.location.href !== '{LOGIN_PAGE_URL}'", timeout=0)
                print("  âœ… æ£€æµ‹åˆ°ç™»å½•æˆåŠŸï¼Œæ¢å¤è‡ªåŠ¨åŒ–ã€‚")
        else:
            print("  âœ… å·²å¤„äºç™»å½•çŠ¶æ€ã€‚")

        if "booking.html" not in page.url:
            page.goto(BOOKING_URL, wait_until='domcontentloaded')
        stopwatch['Login_Check_and_Action'] = timer_login_check.stop()
        print(f"   ç”¨æ—¶ (åŒ…å«äººå·¥ä»‹å…¥): {stopwatch['Login_Check_and_Action']:.3f}s")
        

        if "booking.html" not in page.url:
            page.goto(BOOKING_URL)

        # === ğŸ¯ 3. é«˜ç²¾åº¦ç­‰å¾…é€»è¾‘ (è¿˜åŸä¸å‡çº§) ===
        timer_spin_lock = Timer("Spin_Lock_Wait")
        print("\n4. è¿›å…¥é«˜ç²¾åº¦ç­‰å¾…...")
        while (target_time - datetime.now()).total_seconds() > 5:
            print(f"   â³ ç­‰å¾…è‡³ç›®æ ‡æ—¶é—´ {(target_time - datetime.now()).total_seconds()} ...")
            time.sleep(5)
            
        timer_spin_lock.start()
        start = time.perf_counter()
        print("\n4. è¿›å…¥é«˜ç²¾åº¦ç­‰å¾…Spin_Lock_Wait...")
        wait_seconds = (target_time - datetime.now()).total_seconds()
        while (time.perf_counter() - start) < wait_seconds: pass
        stopwatch['Spin_Lock_Wait'] = timer_spin_lock.stop()
        time.sleep(0.001)
        print(f"   âœ… ç­‰å¾…ç»“æŸã€‚target_time:{target_time}, å½“å‰æ—¶é—´: {datetime.now()}")
        # === 4. æŠ¢åœºå¾ªç¯ (æ•´åˆä¼˜åŒ–ç‰ˆ) ===
        # æ­¤æ—¶æ—¶é—´åˆšåˆ° 8:15:00.000ï¼Œç«‹å³ç‚¹å‡»æ—¥æœŸ
        ensure_correct_date_view(page, target_date_booking, date_str, is_next_month)

        # é¢„åŠ è½½ JS é€»è¾‘ï¼Œé¿å…åœ¨å¾ªç¯ä¸­é‡å¤å®šä¹‰å­—ç¬¦ä¸²
        JS_PICKER_SCRIPT = """
        (args) => {
            const { courtList, h1, h2, maxCount, currentBooked } = args;
            const findAndClick = (hStart, hEnd, preferredCid) => {
                const selector = `button[data-value="${hStart}00|${hEnd}00|${preferredCid}"].available`;
                const el = document.querySelector(selector);
                if (el) {
                    el.click(); // ç›´æ¥åœ¨æµè§ˆå™¨ç«¯è§¦å‘ç‚¹å‡»
                    return true;
                }
                return false;
            };

            let result = { batch: 0, cid: null };
            // å°è¯•é€‰ç¬¬ä¸€ä¸ªæ—¶æ®µ (Slot A)
            for (let cid of courtList) {
                if (findAndClick(h1.s, h1.e, cid)) {
                    result.batch = 1;
                    result.cid = cid;
                    // å¦‚æœé…é¢å…è®¸ï¼Œå°è¯•è¿é€‰ç¬¬äºŒä¸ªæ—¶æ®µ (Slot B)
                    if (currentBooked + 1 < maxCount) {
                        if (findAndClick(h2.s, h2.e, cid)) {
                            result.batch = 2;
                        }
                    }
                    break; 
                }
            }
            return result;
        }
        """

        booked_count = 0
        group_idx = 0
        while group_idx < len(PREFERRED_GROUPS):
            if booked_count >= MAX_BOOKED_COUNT: break
            timer_select = Timer(f"load_page_for_Group_{group_idx}")
            timer_select.start()
            h1_s, h1_e = PREFERRED_GROUPS[group_idx]
            h2_s, h2_e = h1_e, h1_e + 1
            
            # â­ å…³é”®ä¿®æ”¹ï¼šé«˜é¢‘ç›‘å¬ç‰¹å®šæ—¶æ®µçš„æŒ‰é’®æ¸²æŸ“
            # è¿™é‡Œçš„ selector ä¸“é—¨ç›¯ç€ä½ è¦çš„é‚£ä¸ªæ—¶é—´æ®µ
            sync_selector = f'button[data-value^="{h1_s}00|{h1_e}00|"]'
            
            try:
                # ä½¿ç”¨ state='attached' æ¯” 'visible' å¿«ï¼Œå› ä¸ºå…ƒç´ ä¸€è¿›å…¥ HTML æ ‘å°±è§¦å‘
                # timeout è®¾ä¸º 2000msï¼Œé˜²æ­¢é¡µé¢å½»åº•å¡æ­»
                page.wait_for_selector(sync_selector, state='attached', timeout=1000)
            except:
                print(f"âš ï¸ æ—¶æ®µ {h1_s}-{h1_e} æ¸²æŸ“è¶…æ—¶ï¼Œå¯èƒ½è¯¥æ—¶æ®µæ— çƒåœºæˆ–ç½‘ç»œæ‹¥å µã€‚")
                group_idx += 1
                continue
            stopwatch[f'load_page_for_Group_{group_idx}'] = timer_select.stop()

            # --- æ­¤æ—¶æŒ‰é’®å·²æ¸²æŸ“ï¼Œç«‹å³æ‰§è¡ŒåŸæœ¬çš„ JS æ³¨å…¥é€»è¾‘ ---
            timer_select = Timer(f"Select_and_Book_Group_{group_idx}")
            timer_select.start()
            
            picker_data = {
                "courtList": COURT_LIST,
                "h1": {"s": h1_s, "e": h1_e},
                "h2": {"s": h2_s, "e": h2_e},
                "maxCount": MAX_BOOKED_COUNT,
                "currentBooked": booked_count
            }

            try:
                # âš¡ æ‰§è¡Œ JSï¼šåœ¨æµè§ˆå™¨ä¾§å®Œæˆæœç´¢å’Œç‚¹å‡»ï¼Œè¿”å›ç»“æœ
                decision = page.evaluate(JS_PICKER_SCRIPT, picker_data)

                if decision["batch"] > 0:
                    print(f"  âœ… JS é€‰å®š {decision['batch']} åœº (åœºåœ° {decision['cid']})")
                    
                    # 1. æäº¤é¢„å®š
                    page.locator('//*[@id="book-button"]/div/a').click(delay=get_random_delay(10, 30))
                    
                    # 2. ç¡®è®¤é¢„å®š (é’ˆå¯¹é€Ÿåº¦ä¼˜åŒ–ï¼šä½¿ç”¨ attached çŠ¶æ€)
                    confirm_xpath = '//*[@id="cd-popup"]/div/ul/li[2]/a' if TEST_MODE else '//*[@id="cd-popup"]/div/ul/li[1]/a'
                    page.wait_for_selector(confirm_xpath, state='attached', timeout=2000)
                    page.locator(confirm_xpath).click()
                    
                    
                    
                    print(f"ğŸ† æˆåŠŸé¢„å®š {decision['batch']} åœº!")
                    booked_count += decision["batch"]
                    
                    # å¦‚æœè¿˜éœ€è¦ç»§ç»­è®¢ï¼Œåˆ·æ–°/å›åˆ°æ—¥æœŸè§†å›¾
                    if booked_count < MAX_BOOKED_COUNT:
                        ensure_correct_date_view(page, target_date_booking, date_str, is_next_month)
                else:
                    print(f"  âŒ æ—¶æ®µ {h1_s}-{h1_e} æ— å¯ç”¨åœºåœ°ï¼Œè·³è¿‡ã€‚")

            except Exception as e:
                print(f"âŒ è¿è¡Œå¼‚å¸¸: {e}")
                ensure_correct_date_view(page, target_date_booking, date_str, is_next_month)

            stopwatch[f'Select_Group_{h1_s}_{h1_e}'] = timer_select.stop()
            #time.sleep(5)
            
            # ç´¢å¼•è·³è½¬é€»è¾‘
            group_idx += 1
            # å¦‚æœ Slot B ä¹Ÿæ˜¯æˆ‘ä»¬é€‰ä¸­çš„ï¼Œé€»è¾‘ä¸Šå¯ä»¥å¤šè·³ä¸€ä¸ª Index (å–å†³äº PREFERRED_GROUPS çš„æ’å¸ƒ)

        
        print("\n=================================")
        print(f"æ€»è®¡é¢„å®šåœºåœ°æ•°: {booked_count}")
        print("=== âœ¨ è¯¦ç»†è€—æ—¶ç»Ÿè®¡ (ç§’) ===")
        print("| æ­¥éª¤æè¿°                      | è€—æ—¶ (s) |")
        print("|:------------------------------|:---------|")
        for step, t in stopwatch.items():
            print(f"| {step.ljust(30)}| {t:.3f}   |")
        print("=================================")
        
        print("âœ… è„šæœ¬æ‰§è¡Œå®Œæ¯•ï¼Œæµè§ˆå™¨çŠ¶æ€å·²ä¿å­˜ã€‚")
        input("æŒ‰å›è½¦å…³é—­...")
        context.close()

if __name__ == '__main__':
    run_booking_script()
